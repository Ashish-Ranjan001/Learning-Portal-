<div class="edit-category-container card shadow p-4">
  <h2 class="text-center mb-4 text-primary fw-bold">Edit Category</h2>

  <div class="alert alert-success" *ngIf="successMessage">
    {{ successMessage }}
  </div>
  <div class="alert alert-danger" *ngIf="errorMessage">
    {{ errorMessage }}
  </div>

  <form [formGroup]="categoryForm" (ngSubmit)="onSave()">
    <div class="mb-4 text-center">
      <label for="category-image" class="form-label">Category Image:</label>
      <div class="category-image-container">
        <img [src]="categoryForm.get('imageUrl')?.value || 'assets/placeholder-image.png'"
             alt="Category Image"
             class="img-fluid rounded"
             style="max-height: 200px; max-width: 100%; object-fit: contain;">
      </div>
      <input
        id="category-image"
        type="file"
        class="form-control mt-3"
        (change)="onFileSelected($event)"
        accept="image/*">
    </div>

    <div class="mb-3">
      <label for="CategoryName" class="form-label">Name</label>
      <input
        type="text"
        id="CategoryName"
        formControlName="name"
        class="form-control"
        placeholder="Enter Category Name"
        [ngClass]="{'is-invalid': categoryForm.get('name')?.invalid && categoryForm.get('name')?.touched}">
      <div class="invalid-feedback" *ngIf="categoryForm.get('name')?.invalid && categoryForm.get('name')?.touched">
        Name is required.
      </div>
    </div>

    <div class="mb-3">
      <label for="CategorySubSet" class="form-label">Sub Set</label>
      <input
        type="text"
        id="CategorySubSet"
        formControlName="subset"
        class="form-control"
        placeholder="Enter Sub Set"
        [ngClass]="{'is-invalid': categoryForm.get('subset')?.invalid && categoryForm.get('subset')?.touched}">
      <div class="invalid-feedback" *ngIf="categoryForm.get('subset')?.invalid && categoryForm.get('subset')?.touched">
        Sub Set is required.
      </div>
    </div>

    <div class="mb-4 d-flex align-items-center">
      <label for="Status" class="form-label me-3">Active Status:</label>
      <div class="form-check form-switch">
        <input
          type="checkbox"
          id="Status"
          formControlName="status"
          class="form-check-input toggle-switch">
      </div>
      <span class="ms-3 fw-semibold">{{ categoryForm.get('status')?.value ? 'Active' : 'Inactive' }}</span>
    </div>

    <div class="d-flex justify-content-end gap-3">
      <button type="button" class="btn btn-outline-secondary" (click)="onCancel()">Cancel</button>
      <button type="submit" class="btn btn-primary" [disabled]="categoryForm.invalid || isSubmitting">
        <span class="spinner-border spinner-border-sm me-2" *ngIf="isSubmitting"></span>
        Save Changes
      </button>
    </div>
  </form>
</div>

------------------------------------------------------------------------------------



import { ActivatedRoute } from '@angular/router';
import { FormBuilder, FormGroup, FormsModule, ReactiveFormsModule, Validators } from '@angular/forms';
import { Component, OnInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { Router } from '@angular/router';
import { HttpErrorResponse } from '@angular/common/http';
import { finalize } from 'rxjs/operators';
// Import the correct service - update the path as needed
import { CategoriesServiceService } from '../../../services/Categories/categories-service.service';
@Component({
selector: 'app-edit-category',
templateUrl: './edit-category.component.html',
imports: [ReactiveFormsModule, FormsModule, CommonModule],
styleUrls: ['./edit-category.component.css'],
standalone: true
})
export class EditCategoryComponent implements OnInit {
categoryForm: FormGroup;
categoryId!: number;
selectedFile: File | null = null;
isSubmitting = false;
successMessage = '';
errorMessage = '';
constructor(
private route: ActivatedRoute,
private fb: FormBuilder,
private categoryService: CategoriesServiceService,
private router: Router
) {
this.categoryForm = this.fb.group({
name: ['', Validators.required],
subset: ['', Validators.required],  // Changed from 'subSet' to 'subset' to match API response
imageUrl: [''],
status: [false]
});
}
ngOnInit() {
this.route.paramMap.subscribe(params => {
const id = params.get('id');
if (id) {
this.categoryId = Number(id);
this.loadCategoryDetails();
} else {
this.errorMessage = 'Category ID is missing';
console.error('Category ID is missing');
}
});
}
loadCategoryDetails() {
this.categoryService.getCategoryById(this.categoryId).subscribe({
next: (response: any) => {
// Assuming the backend returns data directly or in a 'data' property
const category = response.data || response;
    if (category) {
      console.log('API Response Category:', category);
      this.categoryForm.patchValue({
        name: category.name,
        subset: category.subset,  // This matches the API response field name
        imageUrl: category.imagepath,
        status: category.status
      });
      console.log('Form after patch:', this.categoryForm.value);
    }
  },
  error: (error: any) => {
    this.errorMessage = 'Failed to load category details';
    console.error('Error loading category:', error);
  }
});
}
onFileSelected(event: Event) {
const fileInput = event.target as HTMLInputElement;
if (fileInput.files && fileInput.files.length > 0) {
this.selectedFile = fileInput.files[0];
  // Create a temporary URL for preview
  const reader = new FileReader();
  reader.onload = () => {
    this.categoryForm.patchValue({
      imageUrl: reader.result as string
    });
  };
  reader.readAsDataURL(this.selectedFile);
  
  console.log('Selected File:', this.selectedFile.name);
}
}
onSave() {
if (this.categoryForm.invalid) {
// Mark all fields as touched to trigger validation messages
Object.keys(this.categoryForm.controls).forEach(key => {
const control = this.categoryForm.get(key);
control?.markAsTouched();
});
return;
}
this.isSubmitting = true;
this.successMessage = '';
this.errorMessage = '';

// Create FormData to send multipart/form-data (for file upload)
const formData = new FormData();

// Add form fields to FormData
formData.append('name', this.categoryForm.get('name')?.value);
formData.append('subset', this.categoryForm.get('subset')?.value);  // Changed to match form control name
formData.append('status', this.categoryForm.get('status')?.value);

// Add file if selected
if (this.selectedFile) {
  formData.append('ImageFile', this.selectedFile, this.selectedFile.name);
}

this.categoryService.updateCategory(this.categoryId, formData)
  .pipe(finalize(() => this.isSubmitting = false))
  .subscribe({
    next: (response: any) => {
      console.log('Category Updated Successfully', response);
      console.log('FormData After Sending:', [...formData.entries()]); // Debugging
      this.successMessage = 'Category updated successfully';
      
      // Navigate after a short delay to allow the user to see the success message
      setTimeout(() => {
        this.router.navigate(['dashboard/course/viewCategory']);
      }, 1500);
    },
    error: (error: HttpErrorResponse) => {
      console.error('Error updating category:', error);
      
      if (error.status === 404) {
        this.errorMessage = 'Category not found';
      } else if (error.error && error.error.message) {
        this.errorMessage = error.error.message;
      } else {
        this.errorMessage = 'Failed to update category. Please try again.';
      }
    }
  });
}
onCancel() {
console.log('Edit cancelled');
this.router.navigate(['dashboard/course/viewCategory']);
}
}


---------------------------------------------------------------------------------------------


 public async Task UpdateCategories(int id, CreatCategoriesDtos categoryDto)
 {
     var existingCategory = await _context.Categories.FindAsync(id);

     if (existingCategory == null)
     {
         throw new KeyNotFoundException($"Category with ID {id} not found.");
     }

     
     // Update properties using AutoMapper
     _mapper.Map(categoryDto, existingCategory);

     // If ImageFile is provided, update the stored image
     if (categoryDto.ImageFile != null)
     {
         // Define folder path inside wwwroot - FIXED: Match the same directory structure as AddCategories
         var uploadFolder = Path.Combine(Directory.GetCurrentDirectory(), "wwwroot", "uploadimage");

         if (!Directory.Exists(uploadFolder))
         {
             Directory.CreateDirectory(uploadFolder);
         }

         string uniqueFileName = Guid.NewGuid().ToString() + Path.GetExtension(categoryDto.ImageFile.FileName);
         string filePath = Path.Combine(uploadFolder, uniqueFileName);

         using (var stream = new FileStream(filePath, FileMode.Create))
         {
             await categoryDto.ImageFile.CopyToAsync(stream);
         }

         // FIXED: Save full URL in DB just like in AddCategories method
         existingCategory.imagepath = $"https://localhost:7264/uploadimage/{uniqueFileName}";
     }

     _context.Categories.Update(existingCategory);
     await _context.SaveChangesAsync();
 }
